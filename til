#!/usr/bin/env python3

import sys
import string
import re
import os
from argparse import ArgumentParser


class CaseConverter(object):
  def __init__(self, s):
    self._string = s

  @staticmethod
  def _tokenize(s):
    '''Tokenize strings according to the different string types.

    The string types include flat, kebab, pascal, snake, macro and cobol
    case. All except flat strings can be split.

    :param s: The string to split
    :return: A list of split strings. If the string was not splittable, a
      list containing the original string.
    :rtype: list
    '''
    if not s:
      return None

    # Attempt to split snake case and kebab case.
    groups = re.split('-|_', s)

    if len(groups) > 1:
      return groups

    # Ensure we don't have a fully capitalized string because that results
    # in the following regex splitting each individual character.
    #
    # 'HELLOWORLD' => ['H', 'E', 'L', 'L', ...]
    if re.match('^[A-Z]+$', s):
      return [s]

    firstCharStore = s[0]
    s = firstCharStore.upper() + s[1:]

    groups = re.findall('[A-Z][^A-Z]*', s)

    groups[0] = firstCharStore + groups[0][1:]

    return groups

  @staticmethod
  def _lower(l):
    return map(lambda s: s.lower(), l)

  @staticmethod
  def _upper(l):
    return map(lambda s: s.upper(), l)

  @staticmethod
  def _capitalize(l):
    return map(lambda s: s.capitalize(), l)

  def flat(self):
    return ''.join(self._lower(self._tokenize(self._string)))

  def kebab(self):
    return '-'.join(self._lower(self._tokenize(self._string)))

  def pascal(self):
    return ''.join(self._capitalize(self._tokenize(self._string)))

  def snake(self):
    return '_'.join(self._lower(self._tokenize(self._string)))

  def macro(self):
    return '_'.join(self._upper(self._tokenize(self._string)))

  def cobol(self):
    return '-'.join(self._upper(self._tokenize(self._string)))

  def camel(self):
    tokens = self._tokenize(self._string)

    if len(tokens) == 1:
      return tokens[0].lower()

    formattedTokens = [tokens[0].lower()]
    formattedTokens.extend(self._capitalize(tokens[1:]))

    return ''.join(formattedTokens)


def FlatCase(s):
  return CaseConverter(s).flat()


def KebabCase(s):
  return CaseConverter(s).kebab()


def PascalCase(s):
  return CaseConverter(s).pascal()


def SnakeCase(s):
  return CaseConverter(s).snake()


def MacroCase(s):
  return CaseConverter(s).macro()


def CobolCase(s):
  return CaseConverter(s).cobol()


def CamelCase(s):
  return CaseConverter(s).camel()


def titleFromPath(s):
  title = os.path.basename(os.path.splitext(s)[0]).split('-')
  title[0] = PascalCase(title[0])

  return title


class Topic(object):

  def __init__(self, name: str, path: str):
    self.name = name
    self.path = path

  @staticmethod
  def from_path(path):
    if not os.path.exists(path):
      raise FileNotFoundError(path)

    return Topic(' '.join(titleFromPath(path)), path)


class Subject(object):

  def __init__(self, name: str, anchor: str, path: str):
    self.name = name
    self.anchor = anchor
    self.path = path
    self.topics = []

  def add_topic(self, topic: Topic):
    self.topics.append(topic)

  @staticmethod
  def from_path(path: str):
    title = titleFromPath(path)

    instance = Subject(' '.join(title), KebabCase('-'.join(title)), path)
    
    for filename in os.listdir(path):
      instance.add_topic(Topic.from_path(os.path.join(path, filename)))

    return instance


def renderTopics(subject):
  content = "### {}\n".format(subject.name)

  for topic in subject.topics:
    content = content + "\n" + "- [{}]({})".format(topic.name, topic.path)

  return content


def main(args):
  subjects = []

  dirs = list(filter(
    lambda d: d != '.git' and os.path.isdir(d), 
    sorted(os.listdir())
  ))

  for dirname in dirs:
    subjects.append(Subject.from_path(dirname))

  # Format a string for the table of contents
  toc_format = "- [{}](#{})"
  toc = toc_format.format(subjects[0].name, subjects[0].anchor)
  for subject in subjects[1:]:
    toc = toc + "\n" + toc_format.format(subject.name, subject.anchor)

  # Format a string for the contents.
  body = renderTopics(subjects[0])
  for subject in subjects[1:]:
    body = body + "\n\n" + renderTopics(subject)

  with open('README.md.in', 'r') as f:
    template = f.read()

  template = template.replace('{{toc}}', toc)
  template = template.replace('{{body}}', body)

  with open('README.md', 'w') as f:
    f.write(template)


if __name__ == '__main__':
  main(sys.argv[1:])